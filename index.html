<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gradient Boosting Visual Playground</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #0f172a;
      color: #e5e7eb;
    }
    header {
      padding: 12px 20px;
      border-bottom: 1px solid #1f2937;
      background: #020617;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    header span {
      font-size: 12px;
      opacity: 0.7;
    }
    main {
      display: grid;
      grid-template-columns: 320px minmax(0, 1fr) 320px;
      height: calc(100vh - 52px);
    }
    section {
      border-right: 1px solid #1f2937;
      padding: 10px;
      overflow: auto;
    }
    section:last-child {
      border-right: none;
    }
    h2 {
      font-size: 14px;
      margin: 4px 0 8px;
      font-weight: 600;
    }
    label {
      font-size: 12px;
      display: block;
      margin: 6px 0 2px;
    }
    textarea {
      width: 100%;
      height: 140px;
      background: #020617;
      color: #e5e7eb;
      border-radius: 6px;
      border: 1px solid #374151;
      padding: 6px;
      font-size: 11px;
      resize: vertical;
    }
    select, input[type="number"] {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 12px;
    }
    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 6px 0;
    }
    button {
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #111827;
      color: #e5e7eb;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.1s ease;
    }
    button:hover:not(:disabled) {
      background: #1f2937;
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    #plotCanvas {
      width: 100%;
      height: 100%;
      background: #020617;
      border-radius: 8px;
      border: 1px solid #1f2937;
    }
    #log {
      background: #020617;
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 8px;
      font-size: 11px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    .small {
      font-size: 11px;
      opacity: 0.75;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .row > * {
      flex: 1;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #334155;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: .04em;
      opacity: 0.85;
    }
  </style>
</head>
<body>
<header>
  <div>
    <h1>Gradient Boosting Playground</h1>
    <span>Step through boosting, watch residuals + trees build up</span>
  </div>
  <div class="pill">
    <span>Mode:</span><span>Regression · Tiny GBM</span>
  </div>
</header>

<main>
  <!-- Left: data + controls -->
  <section>
    <h2>1. Data & Setup</h2>
    <p class="small">
      Paste a tiny CSV or load the sample, then choose a target and feature to visualize.
    </p>

    <div class="btn-row">
      <button id="loadSampleBtn">Load sample dataset</button>
      <button id="parseCsvBtn">Parse CSV</button>
    </div>

    <label for="csvInput">CSV input</label>
    <textarea id="csvInput" spellcheck="false" placeholder="feature1,feature2,target
1.0,2.0,5.1
2.0,1.2,4.0
..."></textarea>

    <div id="columnSelectors" style="display:none; margin-top:8px;">
      <label for="targetSelect">Target column (y)</label>
      <select id="targetSelect"></select>

      <label for="plotFeatureSelect">Feature to visualize (x-axis)</label>
      <select id="plotFeatureSelect"></select>

      <div class="row" style="margin-top:8px;">
        <div>
          <label for="learningRateInput">Learning rate</label>
          <input id="learningRateInput" type="number" step="0.01" value="0.1" />
        </div>
        <div>
          <label for="maxStepsInput">Max steps (soft limit)</label>
          <input id="maxStepsInput" type="number" value="20" />
        </div>
      </div>

      <h2 style="margin-top:12px;">2. Boosting control</h2>
      <div class="btn-row">
        <button id="initModelBtn">Init base model</button>
        <button id="nextStepBtn" disabled>Next boosting step</button>
        <button id="resetBtn">Reset</button>
      </div>
      <p class="small" id="statusText">Status: waiting for CSV…</p>
    </div>
  </section>

  <!-- Middle: visualization -->
  <section>
    <h2>3. Visualization</h2>
    <p class="small">
      Blue = true y; green = current model prediction F<sub>m</sub>(x). Step through to see the curve evolve.
    </p>
    <canvas id="plotCanvas" width="800" height="520"></canvas>
  </section>

  <!-- Right: "terminal" -->
  <section>
    <h2>4. Algorithm "terminal"</h2>
    <p class="small">
      Watch pseudo-code + actual numbers for each boosting iteration.
    </p>
    <pre id="log"></pre>
  </section>
</main>

<script>
  // ---- Global-ish state ----
  let parsedData = null;   // { columns, data }
  let matrices = null;     // { X, y, featureNames, featureIndices, targetIndex }
  let boostingState = null; // { basePrediction, trees, learningRate, currentPreds, step }
  let selectedPlotFeatureIndex = 0;

  const csvInputEl = document.getElementById("csvInput");
  const loadSampleBtn = document.getElementById("loadSampleBtn");
  const parseCsvBtn = document.getElementById("parseCsvBtn");
  const columnSelectorsEl = document.getElementById("columnSelectors");
  const targetSelectEl = document.getElementById("targetSelect");
  const plotFeatureSelectEl = document.getElementById("plotFeatureSelect");
  const learningRateInputEl = document.getElementById("learningRateInput");
  const maxStepsInputEl = document.getElementById("maxStepsInput");
  const initModelBtn = document.getElementById("initModelBtn");
  const nextStepBtn = document.getElementById("nextStepBtn");
  const resetBtn = document.getElementById("resetBtn");
  const statusTextEl = document.getElementById("statusText");
  const logEl = document.getElementById("log");
  const plotCanvas = document.getElementById("plotCanvas");
  const ctx = plotCanvas.getContext("2d");

  // ---- Utility: logging ----
  function log(message = "") {
    logEl.textContent += message + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function clearLog() {
    logEl.textContent = "";
  }

  function setStatus(text) {
    statusTextEl.textContent = "Status: " + text;
  }

  // ---- CSV parsing ----
  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/).filter(l => l.trim().length > 0);
    if (lines.length < 2) {
      throw new Error("Need at least a header row + one data row.");
    }
    const columns = lines[0].split(",").map(c => c.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
      const parts = lines[i].split(",");
      if (parts.length !== columns.length) {
        // skip malformed row, but log
        console.warn("Skipping malformed row:", lines[i]);
        continue;
      }
      const row = {};
      for (let j = 0; j < columns.length; j++) {
        const raw = parts[j].trim();
        const num = Number(raw);
        row[columns[j]] = Number.isNaN(num) ? raw : num;
      }
      data.push(row);
    }
    if (!data.length) {
      throw new Error("No valid rows found after parsing.");
    }
    return { columns, data };
  }

  function prepareMatrices(parsed, targetCol) {
    const { columns, data } = parsed;
    const targetIndex = columns.indexOf(targetCol);
    if (targetIndex === -1) {
      throw new Error("Target column not found.");
    }

    // Choose numeric feature columns (excluding target)
    const numericFeatureIndices = [];
    const featureNames = [];
    for (let idx = 0; idx < columns.length; idx++) {
      if (idx === targetIndex) continue;
      const col = columns[idx];
      const allNumeric = data.every(row =>
        typeof row[col] === "number" && !Number.isNaN(row[col])
      );
      if (allNumeric) {
        numericFeatureIndices.push(idx);
        featureNames.push(col);
      }
    }
    if (!numericFeatureIndices.length) {
      throw new Error("No numeric feature columns found (apart from target).");
    }

    const X = [];
    const y = [];
    for (const row of data) {
      const t = row[targetCol];
      if (typeof t !== "number" || Number.isNaN(t)) continue;
      const xRow = numericFeatureIndices.map(idx => row[columns[idx]]);
      X.push(xRow);
      y.push(t);
    }
    if (!X.length) {
      throw new Error("No rows with numeric target values.");
    }

    return { X, y, featureNames, featureIndices: numericFeatureIndices, targetIndex };
  }

  // ---- Tiny regression tree (stump) on residuals ----
  function fitStump(X, residuals) {
    const nSamples = X.length;
    if (nSamples === 0) {
      throw new Error("No samples to fit.");
    }
    const nFeatures = X[0].length;
    let best = null;

    for (let j = 0; j < nFeatures; j++) {
      // Build array of {x, r}
      const arr = [];
      for (let i = 0; i < nSamples; i++) {
        arr.push({ x: X[i][j], r: residuals[i] });
      }
      arr.sort((a, b) => a.x - b.x);

      const n = arr.length;
      const prefixSum = new Array(n + 1).fill(0);
      const prefixSq = new Array(n + 1).fill(0);
      for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + arr[i].r;
        prefixSq[i + 1] = prefixSq[i] + arr[i].r * arr[i].r;
      }

      const totalSum = prefixSum[n];
      const totalSq = prefixSq[n];

      for (let k = 1; k < n; k++) {
        const xLeft = arr[k - 1].x;
        const xRight = arr[k].x;
        if (xLeft === xRight) continue; // avoid meaningless splits

        const threshold = (xLeft + xRight) / 2;

        const nLeft = k;
        const nRight = n - k;

        const sumLeft = prefixSum[k];
        const sumRight = totalSum - sumLeft;

        const sqLeft = prefixSq[k];
        const sqRight = totalSq - sqLeft;

        const leftMean = sumLeft / nLeft;
        const rightMean = sumRight / nRight;

        // SSE = Σ(r^2) - 2 µ Σ(r) + n µ^2
        const lossLeft = sqLeft - 2 * leftMean * sumLeft + nLeft * leftMean * leftMean;
        const lossRight = sqRight - 2 * rightMean * sumRight + nRight * rightMean * rightMean;
        const loss = lossLeft + lossRight;

        if (!best || loss < best.loss) {
          best = {
            featureIndex: j,
            threshold,
            leftValue: leftMean,
            rightValue: rightMean,
            loss
          };
        }
      }
    }

    if (!best) {
      // Fallback: constant tree equal to mean residual
      const meanR = residuals.reduce((a, b) => a + b, 0) / residuals.length;
      return {
        featureIndex: 0,
        threshold: 0,
        leftValue: meanR,
        rightValue: meanR,
        loss: Infinity
      };
    }
    return best;
  }

  function predictStump(stump, xRow) {
    const v = xRow[stump.featureIndex];
    return v <= stump.threshold ? stump.leftValue : stump.rightValue;
  }

  // ---- Boosting helpers ----
  function initBoosting(matrices, learningRate) {
    const { y } = matrices;
    const basePrediction = y.reduce((a, b) => a + b, 0) / y.length;
    const currentPreds = new Array(y.length).fill(basePrediction);

    return {
      basePrediction,
      learningRate,
      trees: [],
      currentPreds,
      step: 0
    };
  }

  function computeMSE(y, preds) {
    let s = 0;
    for (let i = 0; i < y.length; i++) {
      const e = y[i] - preds[i];
      s += e * e;
    }
    return s / y.length;
  }

  function nextBoostingStep() {
    if (!matrices || !boostingState) return;
    const { X, y, featureNames } = matrices;
    const { currentPreds, learningRate } = boostingState;

    const residuals = y.map((yi, i) => yi - currentPreds[i]);
    const stump = fitStump(X, residuals);

    // Update predictions
    for (let i = 0; i < X.length; i++) {
      const h = predictStump(stump, X[i]);
      currentPreds[i] += learningRate * h;
    }

    boostingState.trees.push(stump);
    boostingState.step += 1;

    const mse = computeMSE(y, currentPreds);
    const featureName = featureNames[stump.featureIndex] || `f${stump.featureIndex}`;

    log(`Step ${boostingState.step}`);
    log("Pseudo-code (conceptual):");
    log("  residuals = y - F_prev(x)");
    log("  h_m(x) = fit_tree(X, residuals)");
    log("  F_m(x) = F_prev(x) + learning_rate * h_m(x)");
    log("Actual numbers for this step:");
    log(`  feature used  : ${featureName}`);
    log(`  threshold     : ${stump.threshold.toFixed(4)}`);
    log(`  left value    : ${stump.leftValue.toFixed(4)}`);
    log(`  right value   : ${stump.rightValue.toFixed(4)}`);
    log(`  train MSE     : ${mse.toFixed(6)}`);
    log("────────────────────────────────────────────");

    drawPlot();
    setStatus(`Step ${boostingState.step}, training MSE ≈ ${mse.toFixed(4)}`);
  }

  // ---- Plotting ----
  function drawPlot() {
    ctx.clearRect(0, 0, plotCanvas.width, plotCanvas.height);
    if (!matrices) {
      drawEmptyMessage("Load data and click ‘Init base model’ to begin.");
      return;
    }

    const { X, y, featureNames } = matrices;
    const n = X.length;
    if (!n) {
      drawEmptyMessage("No samples to plot.");
      return;
    }

    const margin = 40;
    const w = plotCanvas.width;
    const h = plotCanvas.height;

    const featIdx = selectedPlotFeatureIndex ?? 0;
    const xVals = X.map(row => row[featIdx]);
    const yVals = [...y];

    // If we have a model, get predictions
    let preds = null;
    if (boostingState) {
      preds = boostingState.currentPreds.slice();
    }

    const minX = Math.min(...xVals);
    const maxX = Math.max(...xVals);
    const minY = Math.min(...yVals, ...(preds || []));
    const maxY = Math.max(...yVals, ...(preds || []));

    const padX = (maxX - minX || 1) * 0.1;
    const padY = (maxY - minY || 1) * 0.1;

    const x0 = minX - padX;
    const x1 = maxX + padX;
    const y0 = minY - padY;
    const y1 = maxY + padY;

    const toScreenX = x =>
      margin + ((x - x0) / (x1 - x0)) * (w - 2 * margin);
    const toScreenY = yVal =>
      h - margin - ((yVal - y0) / (y1 - y0)) * (h - 2 * margin);

    // Axes
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin - 10);
    ctx.lineTo(margin, h - margin);
    ctx.lineTo(w - margin + 10, h - margin);
    ctx.stroke();

    ctx.fillStyle = "#9ca3af";
    ctx.font = "11px system-ui";
    const featName = featureNames[featIdx] || "x";
    ctx.fillText(featName, w / 2, h - 12);
    ctx.save();
    ctx.translate(14, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText("target / prediction", 0, 0);
    ctx.restore();

    // Data points (true y)
    ctx.fillStyle = "#38bdf8";
    for (let i = 0; i < n; i++) {
      const sx = toScreenX(xVals[i]);
      const sy = toScreenY(yVals[i]);
      ctx.beginPath();
      ctx.arc(sx, sy, 3, 0, 2 * Math.PI);
      ctx.fill();
    }

    // Predicted curve (sorted by x)
    if (preds) {
      const pts = [];
      for (let i = 0; i < n; i++) {
        pts.push({ x: xVals[i], y: preds[i] });
      }
      pts.sort((a, b) => a.x - b.x);

      ctx.strokeStyle = "#22c55e";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < pts.length; i++) {
        const sx = toScreenX(pts[i].x);
        const sy = toScreenY(pts[i].y);
        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.stroke();
    }

    // Legend
    ctx.fillStyle = "#e5e7eb";
    ctx.font = "11px system-ui";
    ctx.fillText("● true y", margin + 4, margin - 8);
    ctx.fillStyle = "#22c55e";
    ctx.fillRect(margin + 60, margin - 12, 20, 3);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillText("F_m(x)", margin + 84, margin - 8);
  }

  function drawEmptyMessage(msg) {
    ctx.fillStyle = "#6b7280";
    ctx.font = "13px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(msg, plotCanvas.width / 2, plotCanvas.height / 2);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
  }

  // ---- UI wiring ----
  loadSampleBtn.addEventListener("click", () => {
    const sample = [
      "feature1,feature2,target",
      "0.0,0.0,1.2",
      "0.5,0.2,1.5",
      "1.0,0.1,2.0",
      "1.5,0.4,2.7",
      "2.0,0.3,3.1",
      "2.5,0.6,3.8",
      "3.0,0.9,4.2",
      "3.5,1.1,4.9",
      "4.0,1.4,5.3",
      "4.5,1.6,6.0",
      "5.0,2.0,6.5",
      "5.5,2.3,7.1",
      "6.0,2.5,7.6",
      "6.5,2.7,8.1",
      "7.0,3.0,8.8",
      "7.5,3.2,9.3",
      "8.0,3.4,9.9",
      "8.5,3.7,10.4",
      "9.0,3.9,11.0",
      "9.5,4.2,11.6"
    ].join("\n");
    csvInputEl.value = sample;
    setStatus("Sample dataset loaded. Click ‘Parse CSV’.");
  });

  parseCsvBtn.addEventListener("click", () => {
    try {
      parsedData = parseCSV(csvInputEl.value);
      // Populate target + feature selects
      targetSelectEl.innerHTML = "";
      parsedData.columns.forEach(col => {
        const opt = document.createElement("option");
        opt.value = col;
        opt.textContent = col;
        targetSelectEl.appendChild(opt);
      });

      columnSelectorsEl.style.display = "block";
      setStatus("CSV parsed. Select target + feature, then init model.");
      clearLog();
      log("CSV parsed successfully.");
      log("Choose a target column and feature to plot, then click ‘Init base model’.");
      drawPlot();
    } catch (err) {
      alert(err.message);
      setStatus("CSV parsing failed.");
    }
  });

  targetSelectEl.addEventListener("change", () => {
    // When target changes, we’ll rebuild matrices on init, but update feature list for plotting right away
    if (!parsedData) return;
    try {
      const mats = prepareMatrices(parsedData, targetSelectEl.value);
      matrices = mats;
      // Populate plotFeatureSelect
      plotFeatureSelectEl.innerHTML = "";
      mats.featureNames.forEach((name, idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = name;
        plotFeatureSelectEl.appendChild(opt);
      });
      selectedPlotFeatureIndex = 0;
      setStatus("Target updated. Ready to initialize model.");
      drawPlot();
    } catch (err) {
      alert(err.message);
      setStatus("Error after changing target.");
    }
  });

  plotFeatureSelectEl.addEventListener("change", () => {
    selectedPlotFeatureIndex = Number(plotFeatureSelectEl.value || 0);
    drawPlot();
  });

  initModelBtn.addEventListener("click", () => {
    if (!parsedData) {
      alert("Parse CSV first.");
      return;
    }
    try {
      const targetCol = targetSelectEl.value || parsedData.columns[parsedData.columns.length - 1];
      matrices = prepareMatrices(parsedData, targetCol);

      // (Re)populate plot features if needed
      plotFeatureSelectEl.innerHTML = "";
      matrices.featureNames.forEach((name, idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = name;
        plotFeatureSelectEl.appendChild(opt);
      });
      selectedPlotFeatureIndex = 0;

      const lr = Number(learningRateInputEl.value) || 0.1;
      boostingState = initBoosting(matrices, lr);
      const mse0 = computeMSE(matrices.y, boostingState.currentPreds);

      clearLog();
      log("Base model initialized.");
      log("We start with a constant prediction equal to mean(y).");
      log("");
      log("Pseudo-code:");
      log("  F_0(x) = mean(y)");
      log("");
      log(`Base prediction (mean(y)) = ${boostingState.basePrediction.toFixed(6)}`);
      log(`Initial training MSE       = ${mse0.toFixed(6)}`);
      log("────────────────────────────────────────────");

      nextStepBtn.disabled = false;
      setStatus(`Base model ready. MSE ≈ ${mse0.toFixed(4)}. Click ‘Next boosting step’.`);
      drawPlot();
    } catch (err) {
      alert(err.message);
      setStatus("Could not initialize model.");
    }
  });

  nextStepBtn.addEventListener("click", () => {
    if (!boostingState || !matrices) return;
    const maxSteps = Number(maxStepsInputEl.value) || 999;
    if (boostingState.step >= maxSteps) {
      setStatus(`Hit max steps (${maxSteps}). Reset or increase the limit.`);
      return;
    }
    nextBoostingStep();
  });

  resetBtn.addEventListener("click", () => {
    boostingState = null;
    clearLog();
    setStatus("Reset. Init model again to restart.");
    drawPlot();
  });

  // Initial canvas message
  drawEmptyMessage("Paste CSV or load sample, then parse to get started.");
</script>
</body>
</html>
